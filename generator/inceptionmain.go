/**
 *  Copyright 2014 Paul Querna
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

package generator

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/pquerna/ffjson/shared"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
)

const inceptionMainTemplate = `
// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// DO NOT EDIT!

package main

import (
	"github.com/pquerna/ffjson/inception"
	"{{.ImportName}}"
)

{{$pn := .PackageName}}

func main() {
	i := ffjsoninception.NewInception("{{.InputPath}}", "{{.PackageName}}", "{{.OutputPath}}")
{{range .StructNames}}
	i.Add({{$pn}}.{{.}}{})
{{end}}
	i.Execute()
}
`

type templateCtx struct {
	StructNames []string
	ImportName  string
	PackageName string
	InputPath   string
	OutputPath  string
}

type InceptionMain struct {
	inputPath    string
	outputPath   string
	TempMainPath string
	tempMain     *os.File
}

func NewInceptionMain(inputPath string, outputPath string) *InceptionMain {
	return &InceptionMain{
		inputPath:  inputPath,
		outputPath: outputPath,
	}
}

func getImportName(inputPath string) (string, error) {
	p, err := filepath.Abs(inputPath)
	if err != nil {
		return "", err
	}

	dpath := filepath.Dir(p)

	gopaths := strings.Split(os.Getenv("GOPATH"), string(os.PathListSeparator))

	for _, path := range gopaths {
		gpath, err := filepath.Abs(path)
		if err != nil {
			continue
		}
		rel, err := filepath.Rel(filepath.ToSlash(gpath), dpath)
		if err != nil {
			return "", err
		}

		if len(rel) < 4 || rel[:4] != "src"+string(os.PathSeparator) {
			continue
		}
		return rel[4:], nil
	}
	return "", errors.New(fmt.Sprintf("Could not find source directory: GOPATH=%q REL=%q", gopaths, dpath))

}

func (im *InceptionMain) Generate(packageName string, si []*StructInfo) error {
	var err error

	importName, err := getImportName(im.inputPath)

	if err != nil {
		return err
	}
	importName = filepath.ToSlash(importName)
	// for `go run` to work, we must have a file ending in ".go".
	im.tempMain, err = TempFileWithPostfix("", "ffjson-inception", ".go")
	if err != nil {
		return err
	}

	im.TempMainPath = im.tempMain.Name()
	sn := make([]string, 0)
	for _, st := range si {
		sn = append(sn, st.Name)
	}

	tc := &templateCtx{
		ImportName:  importName,
		PackageName: packageName,
		StructNames: sn,
		InputPath:   im.inputPath,
		OutputPath:  im.outputPath,
	}

	t := template.Must(template.New("inception.go").Parse(inceptionMainTemplate))
	err = t.Execute(im.tempMain, tc)
	if err != nil {
		return err
	}

	out, err := shared.GoFmt(im.TempMainPath)
	if err != nil {
		return err
	}

	_, err = im.tempMain.Seek(0, 0)
	if err != nil {
		return err
	}

	err = im.tempMain.Truncate(0)
	if err != nil {
		return err
	}

	_, err = im.tempMain.Write(out.Bytes())
	if err != nil {
		return err
	}

	return nil
}

func (im *InceptionMain) Run() error {
	var out bytes.Buffer
	var errOut bytes.Buffer

	cmd := exec.Command("go", "run", "-a", im.TempMainPath)
	cmd.Stdout = &out
	cmd.Stderr = &errOut

	err := cmd.Run()

	if err != nil {
		return errors.New(
			fmt.Sprintf("Go Run Failed for: %s\nSTDOUT:\n%s\nSTDERR:\n%s\n",
				im.TempMainPath,
				string(out.Bytes()),
				string(errOut.Bytes())))
	}

	os.Remove(im.TempMainPath)
	return nil
}
