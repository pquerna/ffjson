/**
 *  Copyright 2014 Paul Querna
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

package generator

import (
	"bytes"
	"errors"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"text/template"
)

const inceptionMainTemplate = `
// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// DO NOT EDIT!

package main

import (
	"github.com/pquerna/ffjson/inception"
	"{{.ImportName}}"
)

{{$pn := .PackageName}}

func main() {
	i := ffjsoninception.NewInception("{{.InputPath}}", "{{.PackageName}}", "{{.OutputPath}}")
{{range .StructNames}}
	i.Add({{$pn}}.{{.}}{})
{{end}}
	i.Execute()
}
`

type templateCtx struct {
	StructNames []string
	ImportName  string
	PackageName string
	InputPath   string
	OutputPath  string
}

type InceptionMain struct {
	inputPath    string
	outputPath   string
	tempMainPath string
	tempMain     *os.File
}

func NewInceptionMain(inputPath string, outputPath string) *InceptionMain {
	return &InceptionMain{
		inputPath:  inputPath,
		outputPath: outputPath,
	}
}

func getImportName(inputPath string) (string, error) {
	p, err := filepath.Abs(inputPath)
	if err != nil {
		return "", err
	}

	dpath := filepath.Dir(p)

	gpath, err := filepath.Abs(os.Getenv("GOPATH"))
	if err != nil {
		return "", err
	}

	rel, err := filepath.Rel(gpath, dpath)
	if err != nil {
		return "", err
	}

	if rel[:4] != "src/" {
		return "", errors.New(fmt.Sprintf("Could not find source directory: GOPATH=%q REL=%q", gpath, rel))
	}
	return rel[4:], nil
}

func goFmt(p string) (*bytes.Buffer, error) {
	var out bytes.Buffer
	var errOut bytes.Buffer
	cmd := exec.Command("gofmt", p)
	cmd.Stdout = &out
	cmd.Stderr = &errOut

	err := cmd.Run()

	if err != nil {
		return nil, errors.New(string(errOut.Bytes()))
	}

	return &out, nil
}

func (im *InceptionMain) Generate(packageName string, si []*StructInfo) error {
	var err error

	importName, err := getImportName(im.inputPath)

	if err != nil {
		return nil
	}

	im.tempMain, err = TempFileWithPostfix("", "ffjson-inception", ".go")
	if err != nil {
		return err
	}

	im.tempMainPath = im.tempMain.Name()
	sn := make([]string, 0)
	for _, st := range si {
		sn = append(sn, st.Name)
	}

	tc := &templateCtx{
		ImportName:  importName,
		PackageName: packageName,
		StructNames: sn,
		InputPath:   im.inputPath,
		OutputPath:  im.outputPath,
	}

	t := template.Must(template.New("inception.go").Parse(inceptionMainTemplate))
	err = t.Execute(im.tempMain, tc)
	if err != nil {
		return err
	}

	out, err := goFmt(im.tempMainPath)
	if err != nil {
		return err
	}

	_, err = im.tempMain.Seek(0, 0)
	if err != nil {
		return err
	}

	err = im.tempMain.Truncate(0)
	if err != nil {
		return err
	}

	_, err = im.tempMain.Write(out.Bytes())
	if err != nil {
		return err
	}

	println(im.tempMainPath)

	return nil
}

func (im *InceptionMain) Run() error {
	return nil
}
